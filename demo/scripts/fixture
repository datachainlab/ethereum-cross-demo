#!/usr/bin/env bash
set -euo pipefail

# ==============================================================================
# Configuration
# ==============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="${SCRIPT_DIR}/../.."

FIXTURES_DIR="${ROOT_DIR}/demo/fixtures"
CONF_DIR="${ROOT_DIR}/demo/config"
OUT_DIR="${ROOT_DIR}/out"

# Chain IDs (can be overridden by env)
CHAIN0_ID="${CHAIN0_ID:-31337}"  # ibc0 (coordinator)
CHAIN1_ID="${CHAIN1_ID:-31338}"  # ibc1 (participant)

# Broadcast file paths
BROADCAST0="${ROOT_DIR}/broadcast/DeployAll.s.sol/${CHAIN0_ID}/run-latest.json"
BROADCAST1="${ROOT_DIR}/broadcast/DeployAll.s.sol/${CHAIN1_ID}/run-latest.json"

# List of contracts to exclude (e.g., incompatible ABIs for yrly)
EXCLUDE_LIST=("LibVariable")

# Check for required dependencies
if ! command -v jq &> /dev/null; then
    echo "Error: 'jq' is not installed."
    exit 1
fi

# ==============================================================================
# Helpers
# ==============================================================================

is_excluded() {
    local name="$1"
    for ex in "${EXCLUDE_LIST[@]}"; do
        if [[ "${name}" == "${ex}" ]]; then
            return 0
        fi
    done
    return 1
}

reset_directories() {
    echo ">> Resetting fixtures directory: ${FIXTURES_DIR}"
    rm -rf "${FIXTURES_DIR}"
    
    # Create directory structure
    mkdir -p "${FIXTURES_DIR}/ethereum/ibc0/"{abis,addresses}
    mkdir -p "${FIXTURES_DIR}/ethereum/ibc1/"{abis,addresses}
    mkdir -p "${CONF_DIR}/chains"
}

extract_abis() {
    local dst_dir="$1"
    echo ">> Extracting ABIs to ${dst_dir}"
    mkdir -p "${dst_dir}"

    # Iterate over out directory for JSON artifacts
    find "${OUT_DIR}" -maxdepth 2 -type f -name '*.json' | while read -r artifact; do
        # Skip if no 'abi' field exists
        if ! jq -e 'has("abi")' "${artifact}" >/dev/null 2>&1; then
            continue
        fi

        # Determine contract name
        local name
        name="$(jq -r '.contractName // empty' "${artifact}")"
        if [[ -z "${name}" || "${name}" == "null" ]]; then
            name="$(basename "${artifact}" .json)"
        fi

        if is_excluded "${name}"; then
            echo "  - Skipping ABI for ${name}"
            continue
        fi

        jq '.abi' "${artifact}" > "${dst_dir}/${name}.json"
    done
}

extract_addresses() {
    local broadcast_json="$1"
    local dst_dir="$2"

    echo ">> Extracting addresses from ${broadcast_json} to ${dst_dir}"

    if [[ ! -f "${broadcast_json}" ]]; then
        echo "!! Broadcast file not found: ${broadcast_json}" >&2
        return 1
    fi

    # Extract all transactions with a contractAddress
    jq -r '.transactions[] | select(.contractAddress != null) | "\(.contractName) \(.contractAddress)"' "${broadcast_json}" | \
    while read -r name addr; do
        [[ -z "${name}" || -z "${addr}" ]] && continue

        if is_excluded "${name}"; then
            echo "  - Skipping address for ${name}"
            continue
        fi

        echo "${addr}" > "${dst_dir}/${name}"
    done
}

get_ibc_handler_address() {
    local addr_dir="$1"
    if [[ -f "${addr_dir}/IBCHandler" ]]; then
        cat "${addr_dir}/IBCHandler"
    elif [[ -f "${addr_dir}/OwnableIBCHandler" ]]; then
        cat "${addr_dir}/OwnableIBCHandler"
    else
        echo "!! IBCHandler address file not found in ${addr_dir}" >&2
        return 1
    fi
}

# ==============================================================================
# Main Execution
# ==============================================================================

reset_directories

# 1. ABIs: Extract once from 'out' and copy to both chains
TMP_ABIS_DIR="${FIXTURES_DIR}/_tmp_abis"
extract_abis "${TMP_ABIS_DIR}"

cp -a "${TMP_ABIS_DIR}/." "${FIXTURES_DIR}/ethereum/ibc0/abis/"
cp -a "${TMP_ABIS_DIR}/." "${FIXTURES_DIR}/ethereum/ibc1/abis/"
rm -rf "${TMP_ABIS_DIR}"

# 2. Addresses: Extract from respective broadcast files
extract_addresses "${BROADCAST0}" "${FIXTURES_DIR}/ethereum/ibc0/addresses"
extract_addresses "${BROADCAST1}" "${FIXTURES_DIR}/ethereum/ibc1/addresses"

# 3. Config Generation: Create chain config files from templates
for id in 0 1; do
    echo ">> Generating config for ibc-${id}..."
    ADDR_DIR="${FIXTURES_DIR}/ethereum/ibc${id}/addresses"
    
    IBC_HANDLER_ADDRESS="$(get_ibc_handler_address "${ADDR_DIR}")"

    cat "${CONF_DIR}/template/ibc-${id}.template.json" \
        | jq ".chain.ibc_address |= \"${IBC_HANDLER_ADDRESS}\"" \
        | jq ".chain.multicall3_address |= null" \
        > "${CONF_DIR}/chains/ibc-${id}.json"
done

echo "Done. Fixtures: ${FIXTURES_DIR}, Configs: ${CONF_DIR}/chains"
